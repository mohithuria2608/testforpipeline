// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __awaiter, __extends, __generator } from "tslib";
var PollerStoppedError = /** @class */ (function (_super) {
    __extends(PollerStoppedError, _super);
    function PollerStoppedError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = "PollerStoppedError";
        Object.setPrototypeOf(_this, PollerStoppedError.prototype);
        return _this;
    }
    return PollerStoppedError;
}(Error));
export { PollerStoppedError };
var PollerCancelledError = /** @class */ (function (_super) {
    __extends(PollerCancelledError, _super);
    function PollerCancelledError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = "PollerCancelledError";
        Object.setPrototypeOf(_this, PollerCancelledError.prototype);
        return _this;
    }
    return PollerCancelledError;
}(Error));
export { PollerCancelledError };
var Poller = /** @class */ (function () {
    function Poller(operation) {
        var _this = this;
        this.stopped = true;
        this.pollProgressCallbacks = [];
        this.operation = operation;
        this.promise = new Promise(function (resolve, reject) {
            _this.resolve = resolve;
            _this.reject = reject;
        });
        // This prevents the UnhandledPromiseRejectionWarning in node.js from being thrown.
        // The above warning would get thrown if `poller.poll` is called, it returns an error,
        // and pullUntilDone did not have a .catch or await try/catch on it's return value.
        this.promise.catch(function () { });
    }
    Poller.prototype.startPolling = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.stopped) {
                            this.stopped = false;
                        }
                        _a.label = 1;
                    case 1:
                        if (!(!this.isStopped() && !this.isDone())) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.poll()];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, this.delay()];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    Poller.prototype.pollOnce = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var state, _a, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        state = this.getOperationState();
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 4, , 5]);
                        if (!!this.isDone()) return [3 /*break*/, 3];
                        _a = this;
                        return [4 /*yield*/, this.operation.update({
                                abortSignal: options.abortSignal,
                                fireProgress: this.fireProgress.bind(this)
                            })];
                    case 2:
                        _a.operation = _b.sent();
                        if (this.isDone() && this.resolve) {
                            this.resolve(state.result);
                        }
                        _b.label = 3;
                    case 3: return [3 /*break*/, 5];
                    case 4:
                        e_1 = _b.sent();
                        state.error = e_1;
                        if (this.reject) {
                            this.reject(e_1);
                        }
                        throw e_1;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    Poller.prototype.fireProgress = function (state) {
        for (var _i = 0, _a = this.pollProgressCallbacks; _i < _a.length; _i++) {
            var callback = _a[_i];
            callback(state);
        }
    };
    Poller.prototype.cancelOnce = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this;
                        return [4 /*yield*/, this.operation.cancel(options)];
                    case 1:
                        _a.operation = _b.sent();
                        if (this.reject) {
                            this.reject(new PollerCancelledError("Poller cancelled"));
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    Poller.prototype.poll = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (!this.pollOncePromise) {
            this.pollOncePromise = this.pollOnce(options);
            var clearPollOncePromise = function () {
                _this.pollOncePromise = undefined;
            };
            this.pollOncePromise.then(clearPollOncePromise, clearPollOncePromise);
        }
        return this.pollOncePromise;
    };
    Poller.prototype.pollUntilDone = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.stopped) {
                    this.startPolling().catch(this.reject);
                }
                return [2 /*return*/, this.promise];
            });
        });
    };
    Poller.prototype.onProgress = function (callback) {
        var _this = this;
        this.pollProgressCallbacks.push(callback);
        return function () {
            _this.pollProgressCallbacks = _this.pollProgressCallbacks.filter(function (c) { return c !== callback; });
        };
    };
    Poller.prototype.isDone = function () {
        var state = this.getOperationState();
        return Boolean(state.isCompleted || state.isCancelled || state.error);
    };
    Poller.prototype.stopPolling = function () {
        if (!this.stopped) {
            this.stopped = true;
            if (this.reject) {
                this.reject(new PollerStoppedError("This poller is already stopped"));
            }
        }
    };
    Poller.prototype.isStopped = function () {
        return this.stopped;
    };
    Poller.prototype.cancelOperation = function (options) {
        if (options === void 0) { options = {}; }
        if (!this.stopped) {
            this.stopped = true;
        }
        if (!this.cancelPromise) {
            this.cancelPromise = this.cancelOnce(options);
        }
        else if (options.abortSignal) {
            throw new Error("A cancel request is currently pending");
        }
        return this.cancelPromise;
    };
    Poller.prototype.getOperationState = function () {
        return this.operation.state;
    };
    Poller.prototype.getResult = function () {
        var state = this.getOperationState();
        return state.result;
    };
    Poller.prototype.toString = function () {
        return this.operation.toString();
    };
    return Poller;
}());
export { Poller };
//# sourceMappingURL=poller.js.map